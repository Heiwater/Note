# 简易cmake教程

## cmake 是啥
CMake是一种跨平台的构建工具，用于管理和构建C，C++和其他编程语言的项目。它可以生成Makefile、Visual Studio等工程文件，可用于自动化构建、测试和打包应用程序。CMake使用类似于脚本的语言来描述程序的构建，并可以在多个操作系统上使用。它提供了一种简洁的方法来编写编译脚本，允许开发人员使用统一的接口来构建和管理不同的项目。使用CMake还可以轻松地添加依赖项、自定义构建过程和执行各种构建任务。

> 看上去觉得很厉害，其实就是一个方便你编译的工具

## 怎么用

这里拿Ubuntu举例子（其实自己只试了ubuntu）

1. 安装cmake `sudo apt install cmake`，无脑yes，y就完了
2. `cd`到工作文件目录下面，然后创建个`build`文件夹（默认是build）
3. 然后`cd`到build文件夹里面，`cmake ..`
4. 然后`make`
5. 然后`./xxx`

是不是看着觉得挺简单的，其实这东西挺复杂的，这里聊一下自己项目里面遇到的知识点或者说是踩过的坑吧。

## 女娲补天

### CMakeLists
首先是`CMakeLists.txt`,这个文件里面包含了你这个项目的主要内容，最简单的驱动整个项目只需要三个部分

1. **project(__Project_Name)** 这个就是写项目名字的地方，一般就一行
2. **cmake_minimum_required(VERSION X.X)** 这里写的是项目需要的最小cmake版本，之前试过注释掉这一行内容发现还是可以跑的，不过建议还是老老实实填上去，毕竟不会少一块儿肉
3. **add_executable(.......)** 这里写的是你这个项目需要用到的cpp文件，最简单无脑的情况是把项目全都放在同一个文件夹里面，CMakeLists也在当前文件内，引用的时候把所有的文件全都引入就可以跑起来了。更高级一点的可以设置文件夹，文件名之类的，这里没有过多的了解如果以后需要了自己可以看这个[链接](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)，这玩意儿是官方教程，但是估计不用学的那么的仔细= =

### 代码命令
由于我用的是vscode中的cmake插件，不过我觉得应该差不太多，基本上谨记两个指令`cmake ..`和`make`
> 破案了，自己折腾了一下就是差不多，自己单独的走了一遍没什么问题

要注意的是`cmake ..`这里面有一个**坑**，这个`..`意味着是**上一级文件夹**，以本项目为例我是直接`cd`到`demo`文件夹内然后`cmake`的，因为`CMakeLists`文件在`demo`的上一级文件夹内。如果自己新建一个`build`的话需要老老实实的补全所需的`model，data`之类的文件。

第一次使用`cmake`这个指令的时候会自动创建一系列的文件，能够帮助你完成整个项目，然后`make`一下会创建出一个可执行的`Makefile`。

之后只需要`./projectname`就可以开始啦。

## 瞎扯淡
其实写到这里的时候发现，基本上自己没有怎么用上cmake的内容，甚至可以说是是直接的使用现成的东西，只能说自己应该学的还有很多。

---
# 问问chatgpt

## 是什么

这篇文章介绍了一种名为Go-ICP的技术，它可以高效且全局最优地解决3D点云配准问题。在这项技术中，主要使用了以下数学思想和算法：

1. 非线性优化：Go-ICP使用非线性优化来最小化点云之间的距离。这是通过求解非线性方程组来实现的。

2. 贪心搜索算法：Go-ICP使用贪心搜索算法来寻找点云之间的最佳匹配。这个过程涉及到计算每个点与其它点的距离，然后选择最近的一个作为匹配。

3. 欧式变换：Go-ICP使用欧式变换来将一个点云对齐到另一个点云。这个变换包括平移、旋转和缩放。

## 项目步骤

整个项目的逻辑结构比较复杂，主要包括以下几个步骤：

1. 数据预处理：首先，需要将原始点云的噪声进行过滤，以提高数据质量。同时，也需要对点云进行采样，以便在计算距离时能够高效地处理大型点云。

2. 初始运动估计：通过计算点云之间的初始距离以及匹配关系，可以估计出点云之间的初始运动。这个过程需要使用贪心搜索算法来查找最佳匹配。

3. 迭代优化：在这个步骤中，使用非线性优化来最小化点云之间的距离，并调整点云的运动来达到最佳匹配。这个过程可能需要多次迭代，以达到最佳结果。

4. 结果评估：最后，需要评估配准的结果，以确保它们符合实际要求。这个过程可以通过计算误差矩阵和可视化结果来完成。

## 总结

总的来说，Go-ICP是一个复杂而高效的点云配准技术，它使用了许多数学思想和算法来实现。通过这篇文章，我们可以更好地了解Go-ICP的实现细节，并深入理解其背后的数学原理。

## 如何复现（gpt3）

这篇文章讲的是如何在三维空间中通过点云匹配的方法，将两个不同角度或位置的点云数据集合并成为一个完整的点云数据，从而完成三维重建。

要复现该论文的项目内容，需要使用特定的软件工具，如PCL(Point Cloud Library)和Open3D等，来实现点云数据集的读取、预处理、点对匹配（包括了一些特殊的算法）、求解Rigid body transformation等步骤，并且对算法进行梳理和确定。

具体地说，可以按照以下步骤来完成该项目：

1.准备点云数据集：从网上或者通过其他方法获得点云样本数据集，并注意数据集的格式要与论文中所提及的格式相同。

2.利用PCL或Open3D等软件中提供的API函数读取点云数据集，进行形状、尺寸、重心等预处理，并将点云数据转化为矩阵或张量形式。

3.利用论文中提到的ICP算法来实现点云数据的对齐和匹配。该算法可以细分为以下几个部分：点对筛选（根据距离等因素选择一些点对，且可以根据不同算法来选择其匹配方式），点对权重分配（让更加准确的点对占有更大的权重），单次匹配（利用权重进行对齐），多次迭代（多次循环上述单次匹配过程，直到收敛），求出Rigid body transformation。

4.可视化重建结果：通过可视化工具（如Meshlab）将匹配结果进行可视化，观察结果的准确性和完整性。

需要注意的是，实现该项目需要一定的数学推导基础和编程经验，需要使用C++等编程语言，因此对于高中生而言可能稍显困难。

## 如何复现（gpt4）

要复现Go-ICP: A Globally Optimal Solution to 3D ICP Point-Set Registration论文的项目内容，我们需要遵循以下步骤。这些步骤将指导你设置环境，准备输入数据并运行代码来获取论文中提到的结果。请注意，这个过程可能需要一定熟悉C++编程语言和点云处理的基本概念。

1. 获取代码及相关工具与库：
   先从GitHub上克隆Go-ICP项目的源代码。源代码地址为：https://github.com/yangjiaolong/Go-ICP。
   确保你已经安装了如下工具与库：
   - CMake：用于构建项目
   - Eigen：C++线性代数库
   - PCL (Point Cloud Library)：3D点云处理库，用于点集的输入和输出处理。

2. 编译项目：
   使用CMake和Make构建项目。具体步骤如下
   - 在项目根目录创建名为build的文件夹：`mkdir build`
   - 切换到build文件夹：`cd build`
   - 运行CMake：`cmake ..`
   - 使用make编译项目：`make`

3. 准备输入数据：
   按照论文中的数据描述准备或生成适当的点云数据。这通常包括两个数据集：源点集（model）和目标点集（data）。源点集转换后与目标点集对齐。论文中使用的数据格式为PLY。确保使用相同的格式以方便代码处理。

4. 运行：
   使用以下命令运行Go-ICP：
   `./GoICP model.ply data.ply [Initial_Transformation.txt] [Threshold] [max_runtime] [init_library]`
   其中：
   - model.ply：源点集PLY文件。
   - data.ply：目标点集PLY文件。
   - Initial_Transformation.txt（可选）：文本文件，包含4x4变换矩阵，作为迭代的初始变换。如果不提供此参数，则算法将在旋转和平移空间内随机选择一个初始变换。
   - Threshold（可选）：ICP收敛的误差阈值。例如，1e-10。
   - max_runtime（可选）：设置算法的最大运行时间（以秒为单位）。例如，60。
   - init_library（可选）：包含预计算初始变换集合的文件。如果没有提供，则在第一次运行时创建，并以后复用。

5. 查看结果：
   算法完成后，控制台将显示ICP变换矩阵、误差值和运行时间。你可以将这些数据与论文中的结果进一步进行比较或分析。

请注意，Go-ICP实现中可能存在不同的参数设置。针对特定问题，可能需要调整这些参数。在运行实验时，请确保了解论文中的方法和参数。根据论文的内容和具体应用场景，你可能需要尝试不同的设置。这可以有助于你更好地理解论文中的方法和实验结果。

---
# 回到文章

## 能不能好好好说人话 （glossary）

1. **E.q**：       `equation` 方程，方程式
2. **i.e**：       换言之，简言之。拉丁文`id est`的縮寫。英文就是`that is / in other words`。
3. **SE(3)**:      欧几里得组，描述三维运动空间的符号，通常称为欧几里得组
4. **SO(3)**:      所有环绕着三维欧几里得空间的原点的旋转，组成的群，定义为旋转群.
5. **BnB**：       分支界定法
6. **residual error**：      参差

## Question

### roubust kernal 健壮的内核？这玩意是啥

### solid radius-pi ball 实心半径pi球，是指半径为pi的实心球体么？后面有说用-pi到pi的立方体表示

### L2误差，和机器学习的一样不？自己这里忘的差不多了

### ICP算法，迭代最近点算法

### 欧几里得组，旋转群，几何概念该怎么整？后面学么还是自己下来自己学？

## GO-ICP
这里想写下自己对于整个过程的总结，但是还没有来得及填上去自己的坑就是了

---
# 其他相关

## 点云
也就是当前折腾的这个东西的“数据集”，其实就是存储意见物品的3D信息这玩意被称作点云，官方一点的解释如下：

> 3D 点云是三维空间中的点的数据集， 点云用来表示对象的3D 表面。 每个点由三个坐标(X,YZ)组成唯一标识其相对于正交轴的位置。 通常，R、G、B 颜色值和表面法线等附加信息也可以嵌入为点属性，具体取决于用于捕获点的传感器。 通常意义上的点云包含大量的点（成千上万甚至更多）。

但是现在有个问题，我们现在即将使用的数据集“斯坦福兔子”，这个数据集是`ply`格式的，目前我们用的GO-ICP是用的`TXT`格式进行交互的，所以现在要做的是想办法将两种数据的内容相互转化。

### 相互转换
目前为止已知的是GO-ICP需要的是两个文件一个是model另一个是data，其中文件头的数据是告诉你当前文件内的数据有多少行，后面紧跟的相同行数的内容则是相应的数据内容。

然后斯坦福兔子数据集给的压缩包有好多内容，目前为止的推测是有不同的方向或者说是角度，但是很显然没有现成的东西直接给你使用，所以是不是需要考虑这自己整一个

就目前为止的观察，“bun_zipper.ply”分为三个部分：
1. 1-12行为文件头，告诉你文件里面的内容，里面说到说“element vertex”~~元素顶点？~~有35947个，“element face”~~元素面？~~有69451个
2. 13-35959行，推测是element vertex，正好是35947个，这里面的元素或者说是内容一行有5个，不清楚种类是什么
3. 35960-105410行，那这部分打概率就是element face了，这里一行有4个内容，第一个数字是3后面三个内容则都是4-5位正整数，猜测数字3表示的是3维？后面的则是数值？


然后对比一下之前的内容，可以看出来element vertex就是demo里面的model，同理那么element face就应该是demo中的data。

但是问题来了，data文件里面只有30379行内容并且data的内容跟model内容一样，每一行都是三个0.x有正有负的数字。

然后在网上找到了相关的的[内容解析](https://huangwang.github.io/2019/06/04/PLY%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/)

大概了解了一下内容，前三个是x,y,z后面跟着的两个是confidence 和 intensity 信心和强度？不太懂

### 目前小结
目前为止，看到ply文档基本上先看他的头文件信息，告诉了你这里面的相关参数以及接下来的内容，推测斯坦福兔子的每个名字都应该是方位加上角度，然后里面的头文件是为了方便你可视化进行操作的。

## 交流过后
上午和老师交流了下，说是让咱在github上面找一找相关的项目，有一说一，之前还真的没有想到从github上面找相关的内容，下意识的还是去搜索中文互联网或者是求助谷歌，看来这样的坏习惯还是需要改得啊。

然后被推荐了几个网课和一本书，下载了还没看，任务喜加一。

说说收获，现在突然想到了这个`model`和`data`是什么了，`model`就是记录空间座标的`x,y,z`，而`data`应该就是`r,g,b`，可以说是之前没有想到了

## pointcloudToTXT
在github上面找的[项目](https://github.com/danielTobon43/pointcloudToTXT)发现缺少头文件，下的libpcl-dev居然有1.3g，不知道后续如何但是目前为止感觉不是很靠谱。

东西现在是下完了，但是跑不起来，cmake可以，但是make的时候就有了两个报错，不知道是什么问题，显示的是/usr/include/pcl-1.12/pcl/polygonsh.h这里面的文件，但是这文件是pcl的文件啊，莫名其妙。

### 解决问题
在[评论](https://github.com/danielTobon43/pointcloudToTXT/pull/2)里面看到了有人说如何解决这样的问题的方法：
在`CMakeLists.txt`文件里面的`project(pointcloudToTXT VERSION 1.0.0)`后面添加如下语句：

```cmake
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

不能说非常厉害，只能说是非常牛逼了。这两句话是更改cmake的C++版本的，把版本设置为C++14，就可以使用缺少的lambda函数，但是这个东西是C++11引入的，所以说理论上更改为C++11也可以？

结果出来了，并不是我们预想中的那样，这里输出的结果是xyz以及rgb，这是这里面的rgb都是0 0 0，并不是我们需要的data和model。

## 衔尾蛇
晚上睡觉突然想到会不会model是整个兔子的数据， data是部分角度的数据？垂死病中惊坐起了属于是。

说的没错，是这样的。

# 新的折腾
今天领了新的任务，说是给了一组新的数据让自己看下陪准计算RMSE MAE TRE，这三个值，但是令人高兴的是这三个东西咱都不是很清楚。

给的文件内也存在一些小问题，只有ESM、和GT文件夹内是有内容的，其余的EDM、EDP两个文件夹内是没有东西的。~~后来破案了，就是人家单纯的发错了，没有发全= =~~

这几个文件夹分别代表的是：
1. GT 真值
2. EDM
3. EDP
4. ESM


## 学姐的思路
> 我的想法是 你看能不能把那个变换矩阵抽出来
> 然后去左乘还是右乘待配准的点云得到配准后的点云，你大概试一下

## 杨sir提供的思路
> 你把数据做个采样
> 比如原先50000点，你采样变成5000试一下
> 有可能icp不收敛

所以我们现在先要做的是进行一次数据采样，但是很显然这东西不是说你直接按照大小等比例删除一部分内容就完了的，应该是按照某种方式对原本的数据进行压缩，来减少数据量的大小。

## 结果
喜闻乐见的，跑出来结果了，但是很可惜，学姐提供的思路并不是很正确，最后确实是重新采样了一下，然后跑出来的结果。

用的python的一个库sickit-learn，里面有随机采样的函数，通过chatgpt的辅助完成了随机采样的结果，随机采样到0.1的大小

但是说实话这个大小还是大了，跑一次需要一个小时就比较的难受，或许下次可以试着采集到0.05的大小？