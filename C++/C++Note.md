[toc]

# 从新开始学C++
算是上岸第一步吧

# 聊聊对这本书的看法
感觉这本书更多的是在教你很多东西是如何使用的，而不像是普通的大学教材一样什么都想要扯一点，基本上来说看到目前为止这本书还没有任何地方涉及到任何的算法，目前为止的所有例子都是一个个小的demo或者说是模拟，还行，很好读。

# chapt1&2
前两章因为一块儿看的，所以就把前两张算是值得记录的东西记一手

## 零散的知识点
---

### 面向对象（OOP）与面向过程
> OOP强调的是数据，其理念是设计与问题的本质特性相对应的数据格式。OOP首先设计类，他们准确的标识了程序要处理的东西。OOP不仅仅是将数据和方法合并为类定义，还有助于重用的代码、多态和继承。OOP的中心不是在任务上，而是在表现概念上。
 
面向对象核心是数据和格式，面向过程的核心是结构

之前一直简单的理解面向对象就是把原本可以直接写在`main函数`里面的`子函数`直接拆出来

### C与CPP
> C++是在C的基础上添加了OOP特性，你可以忽略CPP的面向对象特性，但将会错过很多有用的东西

说实话自己以前一直把CPP当做好用的C来用的，STL库用起来确实舒服

### 通用库
说白了就是`iostream`，包含了一些保准的启动代码。

### 编译和链接
早期的CPP使用了一个C++到C的编译器程序（cfront），不过很早C++有自己的独立的编译器了。

### C++编译
在mac上面编译C++是直接`g++ filename.cpp`，然后会生成一个`a.out`文件，直接`./a.out`就可以在控制台里面编译运行了

之前用的Linux记得大差不差，但是编译不只有简单的`g++`这一种，还有很多特殊的骚操作，后续如果学了在这里补上【传送门】

### 函数
函数可以被其他的函数激活或者调用，函数头描述了函数与调用他的函数之间的接口

括号里面的叫形参列表或者参数列表

### main函数的种类
1. int main()：可以简单的理解成程序与操作系统的交互桥梁
2. int main(void)：括号中的void指出函数不接受任何参数
3. void main()：逻辑上和2是一致的，因为void的函数不返回任何值
4. main()：常见于c语言的表头，C++逐渐淘汰

### 名称空间
`using namespace std;`这玩意就是所谓的`using`编译指令。

写出来这句话就表明引用了所有的`std`名称空间，允许你使用`cin`、`cout`之类的，但是没有的话就要老老实实的写：`std::cin`、`std::cout`

对于很多大型的项目来说一次性引用全部的名称空间不是很合适，那么可以试着引用一部分，诸如：`using std::cin`与`using std::cout`

> 记得最早的时候33有给咱演示过，说是可以缩短代码的运行时间，按照这么想确实也是，因为你很多时候就仅仅用个`cin`、`cout`，别的也不咋用
> 可以理解成名称空间相当于是青春版的import，不论是python还是JAVA

### 输入输出流
这个就是经常用的`cin`、`cout`

### 重载
以前一直觉得C++、JAVA之类的才会有重载，没注意到C里面的`*`、`&`也是重载，编译器可以根据上下文语境自主的识别什么意思。
> 别说，想想还挺智能不是。

# chapt 3

# chapt 4

# chapt 5

# chapt 6

## if else
这个结构相对来说比较的简单，硬要说的话就只有一些新鲜的写法

```c++
if(xxxx)

else
    if(xxx)

else
```

这样的书写格式也是正确的

## 逻辑表达式
经典的与或非，没什么新奇的

## 字符函数库 cctype
这个之前没有见到过，简言之就是一个函数库，里面提供了现成的用来判断字符的函数

使用前需要添加头文件`#include <cctyoe>`

具有如下功能：
|   名称   |  返回值  |
|:-:|:-:|
|   isalnum()   |   参数是字母或数字，返回true|
|   isalpha()   |   参数是字母，返回true|
|   iscntrl()   |   参数是控制字符，返回true|
|   isdigit()   |   参数是数字，返回true|
|   isgraph()   |   参数是除空格外的打印字符，返回true|
|   islower()   |   参数是小写字符，返回true|
|   isprint()   |   参数是打印字符（包括空格），返回true|
|   issapce()   |   参数是标准空白字符（包括空格、进纸、换行符、回车、水平制表符或者垂直制表符），返回true|
|   isupper()   |   参数是大写字符，返回true|
|   isxdigit()  |   参数是十六进制数字，返回true|
|   tolower()   |   如果参数是大写字符，返回其小写，否则返回该参数  |
|   toupper()   |   如果参数是小写字符，返回其大写，否则返回该参数  |

## 双目运算符
没啥聊得，`experssion1 : expression2 ? expression3`

如果表达式1正确，则执行2，否则执行3。

## switch语句
记住这玩意每个判断必须要写`break;`否则会继续执行就可以了。

> C++中的case标签只是行标签，而不是选项之间的界限，程序不会执行到下一个case前停止，要让程序执行完特定的一组语句后停止，必须使用break

## break&continue
break直接跳出循环，continue则是跳过当前循环的后半段，继续下一次的循环，这里有个书上很精妙的例子，可以参考下。

```C++
for(int i = 0; line[i] != '\0'; i++)
{
    //逐字输出用户输入的字符，遇到.停止，并且统计用户所输入的空格个数
    cout << line[i];
    if(line[i] == '.')
        break;
    if(line[i] != ' ')
        continue;
    spacesnum ++;
}
```

## 读取数字的循环
这里比较有趣的是假设用户会输入错误的指令，那么就需要重新给予用户指令提示，这里还是照例给出书上的代码进行参考。

```C++
for(int i = 0; i < Max;I++)
{
    //循环读入各个高尔夫击球数据，遇到非数字的情况，进行报错
    cout << "round #" << i+1 << ":";
    while(!(cin >> golf[i])){
        cin.clear();
        while(cin.get() != '\n')
            continue;
        cout << "please enter a number:";
    }
}
```

## 简易I/O
输入输出流需要包含头文件`# include <fstream>`

### 输入
```C++
ifstream inFile;
ifstream fin;
//打开特定的文件
inFile.open("input.txt");
//打开指定的的文件
char filename[50];
cin >> filename;
fin.open(filename);
//记得关闭
inFile.close();
```

### 输出
```C++
ofstream outFile;
ofstream fout;
//打开特定的文件
outFile.open("input.txt");
//打开指定的的文件
char filename[50];
cin >> filename;
fout.open(filename);
//记得关闭
outFile.close();
```

# chapt 7

## 函数的基本知识

### 创建函数
创建函数需要注意三个方面：
1. 定义：就是函数的本体，里面写了这个函数主要是干什么的
2. 提供原型：这个算是C++的书写特点，就是写在main函数之前的只有函数本体第一行的内容，其实可以直接把函数卸载main函数之前，不过这样不是很符合规范就是了
3. 调用：就是用呗

### 为什么需要原型
其实我也有这样的疑问，因为不要原型的话只用单纯的把函数写在main之前就可以了，但是书上提出了一种可能。

当工程体量足够大的时候，如果每一个函数都写在main之前相当于内存需要将所有的功能全部都放到内存里面，这样子对于设备的要求就很高并且会极大程度上的影响到运行的效率。并且有的时候会调用很多文件，编译器在搜索文件的剩余部分的时候就会停止对main函数的编译，影响到效率。

### 有趣的写法
这里介绍了一下C++和ANSI C的一个有趣的写法，就是函数内关键字为空的情况，可以：
1. 直接不填即`void foo()`
2. 填写`void`即`void foo(void)`
3. 填写`...`即`void foo(...)`

### 眼瞎时刻
看书的时候遇到了一个很有意思的排版问题：

```C++
 while(n-- > 0)

 while((n--) > 0)
```

上面的写法不注意的情况下会认为是一个箭头`-->`但是其实运算符有优先级并且遵循从左到右的格式，蛮有意思的。

## 参数传递
在书写的时候圆形的中的变量名不必与定义中的变量名相同，并且可以直接省略：

```CPP
 void foo(int num_a, int num_b);

 void foo(int ,int);
```

换言之对于定义来说，上面两个是一个东西。

## 函数和数组

### 数组即指针
就像之前看C的时候就知道的，数组的本质是一个指针，指向数组的首位地址(即`foo == &foo[0]`)，这里就会有一个很有趣的东西，也就是说下面两种定义在本质上是一个意思：

```CPP
 void foo(int arr[], int num)


 void foo(int *arr, int num)
```

但是写成上面的样子能够更好的提示用户这个地方输入的应该是一个数组，提醒用户arr不仅执行int，并且还只想int数组的第一个int。

于此同时因为数组即指针就意味着除了可以用数组的常规方法使用数组还可以使用指针的方式使用它：`foo+4 == foo[4]`

### 指针和const
先说结论，能够使用const指针（常量指针）的情况下尽量使用常量指针，原因有二：
1. 可以避免由于无意间修改数据而导致的编程错误
2. 使用const是的函数能够处理const和非const实参，否则将只能接受非const数据。如果允许，则将指针形参声明只想const的指针。

说人话就是能够减少错误，前期折磨一点后头debug的时候能够轻松一些。

#### 不同位置的const关键字
试着区分：

```CPP
 int num = 3;
 const int * foo = &num; //const int（常量int）类型的一个指针
 int * const bar = &num; //int类型的一个常量指针
```
首先两个都是指针，不过一个是常量指针，一个是指针。

对于常量指针来说用户不能修改该指针所指向的值，但是却可以修改指向的内容。
本例来说，这里的const只能够放置修改foo指向的值，而不能防止修改foo的值。换言之你可以将一个新的地址赋给foo

```CPP
 int num = 3;
 int new_num = 16;
 const int *foo = &num;

 *foo = 16; //错误的不合法的

 foo = &new_num; //正确的，合法的
```

对于第二个指向int的常量指针则有如下情况：

```CPP
 int num = 3;
 int new_num = 16;
 int * const bar = &num;

 *bar = 16; //正确的，合法的

 bar = &new_num; //错误的不合法的
```

## 函数和二维数组
假如存在一个二维数组`data[3][4]`，则data是一个数组名，该函数有3个元素，每一个元素本身都是一个数组，每个元素由4个int值组成，因此data的类型是指向由4个int组成的数组的指针。则有如下：

```CPP
 int data[3][4] = {{1,2,3,4},{11,12,13,14},{21,22,23,24},{31,32,33,34}};
 int total = sum(data, 3); //3表示相加data数组的3个元素，因为data是一个指向4个int值的一个数组的指针，所以data只有3个元素

 int sum(int arr[][], int size);

 int sum(int (*arr)[4], int size)

 int sum(int *arr[4], int size)

```

后面跟着的三个定义表示的都是同一个东西，说实话基本上用的话别折腾自己，写第一个就好了。

## 函数指针
这里的这一部分比较绕，可以理解成双重否定表肯定的意思，直接贴一段代码：

```CPP
 void estimate(int lines, double (*pf)(int))
 {
    using namespace std;
    cout << lines << " lines will take ";
    cout << (*pf)(lines) << " hours\n";
 }
```

这里的`double (*pf)(int)`表示的是一个指针pf指向一个double类型的函数，函数的输入为一个int值，返回值为double

因为符号优先级的原因，这里必须要加上括号，保证pf是一个指向函数的指针，保证调用的是所需要的函数。